// File: modules/voucherManager.js
// Purpose: Voucher lifecycle manager with TEST_MODE simulation, CSV exports, optional email/print hooks

require('dotenv').config();
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { Client: SSHClient } = require('ssh2');
const nodemailer = require('nodemailer');

// -----------------------------
// Config & Feature Flags
// -----------------------------
const TEST_MODE = process.env.TEST_MODE === 'true';
const DATA_DIR = path.join(__dirname, '..', 'data');
if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });

// Email feature flag
const EMAIL_ENABLED = (process.env.EMAIL_ENABLED || 'false') === 'true';
let transporter = null;
if (EMAIL_ENABLED) {
  transporter = nodemailer.createTransport({
    host: process.env.EMAIL_HOST,
    port: parseInt(process.env.EMAIL_PORT || '587', 10),
    secure: (process.env.EMAIL_SECURE || 'false') === 'true',
    auth: {
      user: process.env.EMAIL_USER,
      pass: process.env.EMAIL_PASS
    }
  });
  console.log('[VoucherManager] Email transporter configured');
}

// Optional print hook (dummy)
const PRINT_ENABLED = (process.env.PRINT_ENABLED || 'false') === 'true';

// RouterOS SSH config
const ROS_HOST = process.env.ROS_HOST || '192.168.88.1';
const ROS_PORT = parseInt(process.env.ROS_PORT || '22', 10);
const ROS_USER = process.env.ROS_USER || 'admin';
const ROS_PASS = process.env.ROS_PASS || '';
const ROS_KEY_PATH = process.env.ROS_KEY_PATH || ''; // optional

// -----------------------------
// Utilities
// -----------------------------
function randomPassword(length = 8) {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz23456789';
  return Array.from({ length }, () => chars[Math.floor(Math.random() * chars.length)]).join('');
}

function sanitize(str) {
  return String(str).replace(/[^\w.\-:@]/g, '_');
}

// Simple CSV writer
function writeCSV(filePath, rows, header) {
  const content = [header, ...rows].join('\n');
  fs.writeFileSync(filePath, content);
  return filePath;
}

// Email helper (best-effort)
async function sendEmail(subject, text) {
  if (!EMAIL_ENABLED || !transporter) return false;
  const to = process.env.EMAIL_TO || process.env.EMAIL_USER;
  try {
    await transporter.sendMail({ from: process.env.EMAIL_FROM || process.env.EMAIL_USER, to, subject, text });
    return true;
  } catch (err) {
    console.warn('[VoucherManager] Email send failed:', err.message);
    return false;
  }
}

// Print helper (stub)
function printSummary(title, lines) {
  if (!PRINT_ENABLED) return false;
  try {
    const file = path.join(DATA_DIR, `print_${Date.now()}.txt`);
    fs.writeFileSync(file, [title, '', ...lines].join('\n'));
    return true;
  } catch (err) {
    console.warn('[VoucherManager] Print write failed:', err.message);
    return false;
  }
}

// -----------------------------
// RouterOS command runner
// -----------------------------
async function ros(cmd) {
  if (TEST_MODE) {
    console.log(`[VoucherManager] TEST MODE: would run -> ${cmd}`);
    // Return simulated outputs for commands we parse
    if (cmd.startsWith('/ip hotspot user print')) {
      // Simulated detailed print
      return [
        'Flags: X - disabled, I - invalid',
        ' 0   name="test1" password="p1" profile="1h-100FCFA" comment="batch-test" disabled=no',
        ' 1 X name="test2" password="p2" profile="3h-200FCFA" comment="batch-old" disabled=yes'
      ].join('\n');
    }
    return '';
  }

  // Real SSH execution
  return new Promise((resolve, reject) => {
    const conn = new SSHClient();
    const connOpts = {
      host: ROS_HOST,
      port: ROS_PORT,
      username: ROS_USER
    };

    if (ROS_KEY_PATH && fs.existsSync(ROS_KEY_PATH)) {
      connOpts.privateKey = fs.readFileSync(ROS_KEY_PATH);
    } else {
      connOpts.password = ROS_PASS;
    }

    conn.on('ready', () => {
      conn.exec(cmd, (err, stream) => {
        if (err) {
          conn.end();
          return reject(err);
        }
        let stdout = '';
        let stderr = '';
        stream.on('close', () => {
          conn.end();
          if (stderr) return reject(new Error(stderr));
          resolve(stdout.trim());
        }).on('data', (data) => {
          stdout += data.toString();
        }).stderr.on('data', (data) => {
          stderr += data.toString();
        });
      });
    }).on('error', (err) => {
      reject(err);
    }).connect(connOpts);
  });
}

// -----------------------------
// Parsing Helpers
// -----------------------------
function parseUsersPrint(output) {
  // Parses lines like:
  // 0   name="test1" password="p1" profile="1h-100FCFA" comment="batch-test" disabled=no
  const users = [];
  const lines = output.split('\n').map(l => l.trim()).filter(Boolean);
  for (const line of lines) {
    if (!/name=/.test(line)) continue;
    const m = {
      name: (line.match(/name="([^"]+)"/) || [,''])[1],
      password: (line.match(/password="([^"]+)"/) || [,''])[1],
      profile: (line.match(/profile="([^"]+)"/) || [,''])[1],
      comment: (line.match(/comment="([^"]+)"/) || [,''])[1],
      disabled: (line.match(/disabled=(yes|no)/) || [,'no'])[1]
    };
    if (m.name) {
      users.push({
        name: m.name,
        password: m.password || '',
        profile: m.profile || 'default',
        comment: m.comment || '',
        status: m.disabled === 'yes' ? 'blocked' : 'active'
      });
    }
  }
  return users;
}

// -----------------------------
// Core Voucher Operations
// -----------------------------
async function userExists(username) {
  const out = await ros(`/ip hotspot user print where name=${sanitize(username)}`);
  return out.includes(`name="${username}"`);
}

async function addUser(username, password, profile, batch) {
  return ros(`/ip hotspot user add name=${sanitize(username)} password=${sanitize(password)} profile=${sanitize(profile)} comment=${sanitize(batch)}`);
}

async function fetchUsers() {
  const out = await ros('/ip hotspot user print detail');
  const users = parseUsersPrint(out);
  return users;
}

async function blockVoucher(username) {
  return ros(`/ip hotspot user set [find name=${sanitize(username)}] disabled=yes`);
}

async function deleteVoucher(username) {
  return ros(`/ip hotspot user remove [find name=${sanitize(username)}]`);
}

async function createBatch(count, profile, batch) {
  const created = [];
  const tag = batch ? sanitize(batch) : `batch-${Date.now()}`;
  for (let i = 0; i < Number(count || 1); i++) {
    const username = `${tag}-${crypto.randomInt(100000, 999999)}-${i}`;
    const password = randomPassword(8);
    await addUser(username, password, profile, tag);
    created.push({ name: username, password, profile, comment: tag, status: 'active' });
  }

  // Notify (optional)
  const lines = created.map(v => `${v.name},${v.password},${v.profile},${v.comment}`);
  await sendEmail(`Vouchers created: ${created.length}`, lines.join('\n'));
  printSummary('Vouchers created', lines);

  return created;
}

async function exportAll() {
  const users = await fetchUsers();
  const file = path.join(DATA_DIR, 'vouchers_all.csv');
  const header = 'Username,Password,Profile,Batch,Status';
  const rows = users.map(u => `${u.name},${u.password},${u.profile},${u.comment},${u.status}`);
  writeCSV(file, rows, header);
  return users;
}

async function exportBatch(batch) {
  const users = await fetchUsers();
  const tag = sanitize(batch);
  const filtered = users.filter(u => (u.comment || '') === tag);
  const file = path.join(DATA_DIR, `vouchers_${tag}.csv`);
  const header = 'Username,Password,Profile,Batch,Status';
  const rows = filtered.map(u => `${u.name},${u.password},${u.profile},${u.comment},${u.status}`);
  writeCSV(file, rows, header);
  return filtered;
}

async function exportProfiles() {
  const users = await fetchUsers();
  const profiles = [...new Set(users.map(u => u.profile))];
  for (const profile of profiles) {
    const subset = users.filter(u => u.profile === profile);
    const file = path.join(DATA_DIR, `vouchers_${sanitize(profile)}.csv`);
    const header = 'Username,Password,Profile,Batch,Status';
    const rows = subset.map(u => `${u.name},${u.password},${u.profile},${u.comment},${u.status}`);
    writeCSV(file, rows, header);
  }
  return profiles;
}

async function getStats() {
  const users = await fetchUsers();
  const total = users.length;
  const blocked = users.filter(u => u.status === 'blocked').length;
  const active = total - blocked;
  const byProfile = users.reduce((acc, u) => {
    acc[u.profile] = (acc[u.profile] || 0) + 1;
    return acc;
  }, {});
  return { total, active, blocked, byProfile };
}

// -----------------------------
// Exports
// -----------------------------
module.exports = {
  // utils
  randomPassword,
  // core
  userExists,
  addUser,
  fetchUsers,
  createBatch,
  exportAll,
  exportBatch,
  exportProfiles,
  blockVoucher,
  deleteVoucher,
  getStats
};

